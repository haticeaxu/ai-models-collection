# -*- coding: utf-8 -*-
"""Final_Sayisal_Goruntu.ipynb adlı not defterinin kopyası

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1861tbjhYiutwY5XOTpfC_HnjtqSm9sp3
"""

from google.colab import drive
drive.mount('/content/drive')

"""# 1.	Kütüphanelerin İçe Aktarılması



Veri işleme için pandas, sayısal işlemler için numpy, opencv ve skimage görselleştirme için matplotlib ve seaborn kütüphanelerini içe aktarıyoruz.







"""

import os
import pandas as pd
from skimage import io, exposure, morphology, measure
from skimage.filters import try_all_threshold, threshold_otsu, threshold_li
from scipy.ndimage import gaussian_filter, median_filter
import matplotlib.pyplot as plt
import numpy as np
import cv2

"""# 2. Görüntü Yükleme ve Görselleştirme İşlemlerine Başlıyoruz
### Görünülerin bulunduğu dosya yolu ve listesini alıyoruz



"""

image_folder = '/content/drive/MyDrive/goruntu_akciger'

image_files = os.listdir(image_folder)

"""### Görüntü dosyalarını bir DataFrame'e ekleliyoruz"""

train_df = pd.DataFrame({'Image': image_files})

"""### Rastgele Görüntüler Seçiyoruz


"""

random_images = train_df.sample(n=9, random_state=42)

selected_images = [
    io.imread(os.path.join(image_folder, img), as_gray=True)
    for img in random_images['Image']
]

"""### Görüntüleri 3x3 matris halinde görselleştirerek veri setindeki örnek görüntüleri inceliyoruz"""

plt.figure(figsize=(12, 12))
for i, img in enumerate(selected_images):
    plt.subplot(3, 3, i + 1)  # 3x3 matris halinde görselleştirme
    plt.imshow(img, cmap='gray')
    plt.title(random_images['Image'].iloc[i])  # Görüntü isimlerini başlık olarak ekler
    plt.axis('off')
plt.tight_layout()
plt.show()

"""#3. Görüntü İşleme ve İyileştirme (Pre-processing)

###3.1. Crop, görüntüyü kenarlardan kırpmak için kullanılan basit bir fonksiyon. Varsayılan olarak her kenardan 50 piksel kırpar. Manuel ya da dinamik olarak seçim yapılabilir.

  Parametreler:
  
    - top: Üstten kırpılacak piksel sayısı
    - bottom: Alttan kırpılacak piksel sayısı
    - left: Soldan kırpılacak piksel sayısı
    - right: Sağdan kırpılacak piksel sayısı
"""

# Görüntüyü sabit parametrelerle kırpma fonksiyonu
  def crop_image(image, top=60, bottom=160, left=100, right=100):
      """Görüntüyü her bir kenardan sabit piksel değerleriyle kırpar."""
      if image.shape[0] <= (top + bottom) or image.shape[1] <= (left + right):
            raise ValueError("Kırpma parametreleri görüntü boyutlarından büyük olamaz.")
      return image[top:image.shape[0]-bottom, left:image.shape[1]-right]

# Orijinal ve kırpılmış görüntüleri görselleştir
    cropped_images = [crop_image(img, top=80, bottom=150, left=80, right=80) for img in selected_images]

    plt.figure(figsize=(18, 12))

    for i, (original, cropped) in enumerate(zip(selected_images, cropped_images)):
        # Orijinal görüntü
        plt.subplot(2, 9, i + 1)
        plt.imshow(original, cmap='gray')
        plt.title("Orijinal")
        plt.axis("off")

        # Kırpılmış görüntü
        plt.subplot(2, 9, i + 10)
        plt.imshow(cropped, cmap='gray')
        plt.title("Kırpılmış")
        plt.axis("off")

    plt.tight_layout()
    plt.show()

"""###3.2. Kontrast Germe (Stretching) ve Histogram Eşitleme (Equalization)"""

# 2. Aşama: Kontrast Germe (Stretching) ve Histogram Eşitleme (Equalization)
    def contrast_stretching(image):
        """Görüntüye kontrast germe işlemi uygular."""
        p2, p98 = np.percentile(image, (2, 98))  # %2 ve %98 yüzdelik değerlerini al
        stretched_image = exposure.rescale_intensity(image, in_range=(p2, p98))
        return stretched_image

    def histogram_equalization(image):
        """Görüntüye histogram eşitleme işlemi uygular."""
        equalized_image = exposure.equalize_hist(image)
        return equalized_image

    # Kontrast germe ve histogram eşitleme işlemlerini uygula
    stretched_images = [contrast_stretching(img) for img in cropped_images]
    equalized_images = [histogram_equalization(img) for img in cropped_images]

    # Dönüşüme uğramış görüntüleri görselleştir
    plt.figure(figsize=(18, 18))

    for i, (cropped, stretched, equalized) in enumerate(zip(cropped_images, stretched_images, equalized_images)):
        # Kırpılmış görüntü
        plt.subplot(3, 9, i + 1)
        plt.imshow(cropped, cmap='gray')
        plt.title("Kırpılmış")
        plt.axis("off")

        # Kontrast gerilmiş görüntü
        plt.subplot(3, 9, i + 10)
        plt.imshow(stretched, cmap='gray')
        plt.title("Stretching")
        plt.axis("off")

        # Histogram eşitlenmiş görüntü
        plt.subplot(3, 9, i + 19)
        plt.imshow(equalized, cmap='gray')
        plt.title("Equalization")
        plt.axis("off")

    plt.tight_layout()
    plt.show()

"""### 3.3. Gürültü Azaltma İşlemleri (Median ve Gaussian Blur)"""

# 3. Aşama: Gürültü Azaltma İşlemleri (Median ve Gaussian Blur)
    def apply_gaussian_blur(image, sigma=1):
        """Gaussian Blur yöntemiyle gürültü azaltır."""
        return gaussian_filter(image, sigma=sigma)

    def apply_median_filter(image, size=3):
        """Median Filter yöntemiyle gürültü azaltır."""
        return median_filter(image, size=size)

    # Gürültü azaltma işlemlerini uygula
    gaussian_blurred_images = [apply_gaussian_blur(img) for img in equalized_images]
    median_filtered_images = [apply_median_filter(img) for img in equalized_images]

    # Gürültü azaltılmış görüntüleri görselleştir
    plt.figure(figsize=(18, 18))

    for i, (equalized, gaussian_blurred, median_filtered) in enumerate(zip(equalized_images, gaussian_blurred_images, median_filtered_images)):
        # Histogram eşitlenmiş görüntü
        plt.subplot(3, 9, i + 1)
        plt.imshow(equalized, cmap='gray')
        plt.title("Equalized")
        plt.axis("off")

        # Gaussian Blur uygulanmış görüntü
        plt.subplot(3, 9, i + 10)
        plt.imshow(gaussian_blurred, cmap='gray')
        plt.title("Gaussian Blur")
        plt.axis("off")

        # Median Filter uygulanmış görüntü
        plt.subplot(3, 9, i + 19)
        plt.imshow(median_filtered, cmap='gray')
        plt.title("Median Filter")
        plt.axis("off")

    plt.tight_layout()
    plt.show()

"""# 3.4. Gauss Yoğunluk Dönüşümü ile Eşikleme"""

# 4. Aşama: Gauss Yoğunluk Dönüşümü ile Eşikleme
    def gaussian_intensity_transform(image, mean=None, std=None):
        """Görüntüye Gauss yoğunluk dönüşümü uygular ve eşikleme yapar."""
        if mean is None:
            mean = np.mean(image)
        if std is None:
            std = np.std(image)

        lower_bound = mean - std
        upper_bound = mean + std

        transformed_image = np.clip(image, lower_bound, upper_bound)
        transformed_image = (transformed_image - lower_bound) / (upper_bound - lower_bound)  # Normalize et
        return transformed_image

    # Eşikleme işlemini uygula
    gaussian_transformed_images = [gaussian_intensity_transform(img) for img in gaussian_blurred_images]

    # Eşiklenmiş görüntüleri görselleştir
    plt.figure(figsize=(18, 12))

    for i, (original, transformed) in enumerate(zip(gaussian_blurred_images, gaussian_transformed_images)):
        # Orijinal Gaussian Blur görüntü
        plt.subplot(2, 9, i + 1)
        plt.imshow(original, cmap='gray')
        plt.title("Gaussian Blur")
        plt.axis("off")

        # Gauss yoğunluk dönüşümü uygulanmış görüntü
        plt.subplot(2, 9, i + 10)
        plt.imshow(transformed, cmap='gray')
        plt.title("Gaussian Transform")
        plt.axis("off")

    plt.tight_layout()
    plt.show()

"""Görüntülerin Gauss Yoğunluk Dağılımı"""

import numpy as np
import matplotlib.pyplot as plt

# Her kırpılmış görüntü için ortalama ve standart sapma hesapla
means = [np.mean(img) for img in cropped_images]
stds = [np.std(img) for img in cropped_images]

# Kırpılmış görüntüler için Gauss yoğunluk dağılımını görselleştir
for i, (image, mean, std) in enumerate(zip(cropped_images, means, stds)):
    plt.figure(figsize=(6, 4))  # Grafik boyutunu ayarla

    # Yoğunluk değerlerini temsil eden x ekseni (0-255 arası)
    x = np.linspace(0, 255, 256)

    # Gauss yoğunluk fonksiyonunu hesapla
    gauss_curve = (1 / (std * np.sqrt(2 * np.pi))) * np.exp(-0.5 * ((x - mean) / std) ** 2)

    # Gauss eğrisini çiz
    plt.plot(x, gauss_curve, color='red', label='Gauss Dağılımı')

    # Ortalama değeri gösteren dikey çizgi
    plt.axvline(mean, color='black', linestyle='--', label='Ortalama')

    # -1 ve +1 standart sapmaları gösteren dikey çizgiler
    plt.axvline(mean - std, color='blue', linestyle='--', label='-1 Std')
    plt.axvline(mean + std, color='blue', linestyle='--', label='+1 Std')

    # Grafik başlık ve etiketlerini ayarla
    plt.title(f"Görüntü {i + 1} - Gauss Yoğunluk Dağılımı")
    plt.xlabel("Yoğunluk Değeri (0-255)")
    plt.ylabel("Olasılık Yoğunluğu")

    # Grafik açıklama ve ızgara ekle
    plt.legend()
    plt.grid()

    # Grafiği göster
    plt.show()

"""### 3.4.	Eşik Sayısı Eelirleme"""

import numpy as np
import matplotlib.pyplot as plt
from skimage.filters import threshold_multiotsu
from scipy.stats import norm

def gaussian_intensity_transform(image):
    """Görüntüye Gauss yoğunluk dönüşümü uygular ve dinamik eşikleme yapar."""

    mean = np.mean(image)  # Dinamik Ortalama
    std = np.std(image)    # Dinamik Standart Sapma

    lower_bound = mean - std
    upper_bound = mean + std

    # Yoğunluğu normalize et (Bu aralıkta kalan pikseller vurgulanacak)
    transformed_image = np.clip(image, lower_bound, upper_bound)
    transformed_image = (transformed_image - lower_bound) / (upper_bound - lower_bound)

    return transformed_image, mean, std

# 🔹 Örnek: Kırpılmış Görüntüler için Gauss Dönüşümü ve Histogram Çizimi
for i, cropped_image in enumerate(cropped_images):
    transformed_image, mean, std = gaussian_intensity_transform(cropped_image)

    # Histogram Grafiği
    plt.figure(figsize=(8, 5))
    x = np.linspace(0, 255, 256)
    gauss_curve = norm.pdf(x, mean, std)  # Gauss Dağılımı
    plt.plot(x, gauss_curve, color='red', label='Gauss Dağılımı')

    # Ortalama ve Standart Sapma Çizgileri
    plt.axvline(mean, color='black', linestyle='--', label='Ortalama')
    plt.axvline(mean - std, color='blue', linestyle='--', label='-1 Std')
    plt.axvline(mean + std, color='blue', linestyle='--', label='+1 Std')

    plt.title("Intensity Transformation için Gauss Dağılımı")
    plt.xlabel("Yoğunluk Değeri (0-255)")
    plt.ylabel("Dağılım (Olasılık Yoğunluğu)")
    plt.legend()
    plt.grid()
    plt.show()

    # 🔹 Tek eşik mi? Çoklu eşik mi? Kullanıcı tercihi
    num_thresholds = 2  # 2 için alt-orta-üst, 5 için detaylı bölgeleme

    # Multi-Otsu ile Bölgelere Ayırma
    thresholds = threshold_multiotsu(cropped_image, classes=num_thresholds + 1)
    multi_thresholded_image = np.digitize(cropped_image, bins=thresholds)

    # Orta bölgeyi 1, diğer her şeyi 0 yap
    binary_segmented = np.where((multi_thresholded_image == 1), 1, 0)

    # 🔹 Segmentasyonu Görselleştir
    plt.figure(figsize=(12, 6))
    plt.subplot(1, 3, 1)
    plt.imshow(cropped_image, cmap='gray')
    plt.title("Orijinal Kırpılmış Görüntü")
    plt.axis("off")

    plt.subplot(1, 3, 2)
    plt.imshow(transformed_image, cmap='gray')
    plt.title("Gauss Yoğunluk Dönüşümü")
    plt.axis("off")

    plt.subplot(1, 3, 3)
    plt.imshow(binary_segmented, cmap='gray')
    plt.title("Optimum Eşikleme Sonucu")
    plt.axis("off")

    plt.tight_layout()
    plt.show()

"""# 4. Thresholding
### 4.1. Thresholding (Global ve Otsu): Eşik değerlerini görüntülere uygulayarak binary görüntüleri görselleştirip uygun thresholding yöntemini seçildi ve yorumlar eklendi.
"""

# 5. Aşama: Thresholding (Global ve Otsu)
    binary_images = []
    for i, cropped in enumerate(cropped_images):
        # Global Thresholding
        global_thresh = np.mean(cropped)
        binary_global = cropped > global_thresh

        # Otsu Thresholding
        otsu_thresh = threshold_otsu(cropped)
        binary_otsu = cropped > otsu_thresh

        # Otsu sonucu seçiliyor (örnek)
        binary_images.append(binary_otsu)

        # Tüm threshold yöntemlerini göster
        fig, ax = try_all_threshold(cropped, figsize=(10, 8), verbose=False)
        plt.suptitle(f"Görüntü {i+1} - Tüm Threshold Yöntemleri", fontsize=16)
        plt.show()

        # Sonuçları görselleştir
        plt.figure(figsize=(12, 6))

        # Orijinal görüntü
        plt.subplot(1, 3, 1)
        plt.imshow(cropped, cmap='gray')
        plt.title("Kırpılmış")
        plt.axis("off")

        # Global Thresholding sonucu
        plt.subplot(1, 3, 2)
        plt.imshow(binary_global, cmap='gray')
        plt.title(f"Global Thresh (T={global_thresh:.2f})")
        plt.axis("off")

        # Otsu Thresholding sonucu
        plt.subplot(1, 3, 3)
        plt.imshow(binary_otsu, cmap='gray')
        plt.title(f"Otsu Thresh (T={otsu_thresh:.2f})")
        plt.axis("off")

        plt.tight_layout()
        plt.show()

        # Yorumlama için bilgi ekle
        print(f"Görüntü {i+1}:")
        print(f"  - Global Thresholding ile belirlenen eşik: {global_thresh:.2f}")
        print(f"  - Otsu Thresholding ile belirlenen eşik: {otsu_thresh:.2f}")
        print("  Yorum: Global Thresholding, sabit bir eşik değerine dayalıdır ve kontrast düşükse yetersiz kalabilir. ")
        print("         Otsu Thresholding ise histogram bilgisine dayalıdır ve daha adaptiftir, genellikle daha iyi sonuç verir.")
        print("\n")

"""# 5. Post-Processing (Morfolojik Operasyonlar)

### 5.1.	Uygun morfolojik operatörleri, uygun structural element yapısı ve boyutunu seçerek görüntüye uygulayınız. Giriş ve Çıkış Görüntülerini görseleştirin
"""

from skimage import morphology
import matplotlib.pyplot as plt

# Structural Element Seçimi
struct_elem = morphology.disk(3)  # Disk şeklinde kernel

for i, binary_image in enumerate(binary_images):
    # 1️⃣ Açma İşlemi (Opening) → Küçük gürültüleri temizler
    opened_image = morphology.binary_opening(binary_image, struct_elem)

    # 2️⃣ Kapama İşlemi (Closing) → Küçük boşlukları kapatır
    closed_image = morphology.binary_closing(opened_image, struct_elem)

    # 3️⃣ Erozyon ve Dilasyon Testi
    eroded_image = morphology.binary_erosion(binary_image, struct_elem)
    dilated_image = morphology.binary_dilation(binary_image, struct_elem)

    # 🔹 Görselleştirme
    plt.figure(figsize=(18, 12))

    plt.subplot(2, 3, 1)
    plt.imshow(binary_image, cmap='gray')
    plt.title("Orijinal Binary Görüntü")
    plt.axis("off")

    plt.subplot(2, 3, 2)
    plt.imshow(opened_image, cmap='gray')
    plt.title("Açma İşlemi (Opening)")
    plt.axis("off")

    plt.subplot(2, 3, 3)
    plt.imshow(closed_image, cmap='gray')
    plt.title("Kapama İşlemi (Closing)")
    plt.axis("off")

    plt.subplot(2, 3, 4)
    plt.imshow(eroded_image, cmap='gray')
    plt.title("Erozyon (Erosion)")
    plt.axis("off")

    plt.subplot(2, 3, 5)
    plt.imshow(dilated_image, cmap='gray')
    plt.title("Dilasyon (Dilation)")
    plt.axis("off")

    plt.tight_layout()
    plt.show()

    # Bilgilendirme
    print(f"Görüntü {i+1} için Morfolojik İşlemler Tamamlandı.")
    print("  - Açma (Opening): Küçük gürültüler temizlendi.")
    print("  - Kapama (Closing): Nesne üzerindeki boşluklar dolduruldu.")
    print("  - Erozyon: Nesne sınırları daraltıldı.")
    print("  - Dilasyon: Nesne sınırları genişletildi.")
    print("\n")

"""### 5.2.	Görüntüye bağlantı bileşen analizi (connected component labeling-CCL) (cv2.connectedComponents) uygulayarak olası bölge sayısını print CCL çıktısını plot edin."""

import cv2
import numpy as np
import matplotlib.pyplot as plt

for i, binary_image in enumerate(binary_images):
    # 🔹 OpenCV'nin connectedComponents fonksiyonunu kullanarak CCL uygulama
    num_labels, labels_im = cv2.connectedComponents(binary_image.astype(np.uint8))

    # 🔹 CCL Çıktısını Görselleştirme (Her bölge farklı renk alır)
    plt.figure(figsize=(8, 6))
    plt.imshow(labels_im, cmap='nipy_spectral')
    plt.title(f"Görüntü {i+1} - Bağlantılı Bileşenler (CCL)")
    plt.axis("off")
    plt.colorbar()
    plt.show()

    # 🔹 Bölge Sayısını Ekrana Yazdır
    print(f"Görüntü {i+1} için bağlantılı bileşen sayısı: {num_labels}")

    # 🔹 Detaylı Bölge Bilgileri (Connected Components with Stats)
    num_labels, labels_im, stats, centroids = cv2.connectedComponentsWithStats(binary_image.astype(np.uint8))

    print(f"\nGörüntü {i+1} için bağlantılı bileşen analizi sonuçları:")
    for label in range(1, num_labels):  # 0 etiketi arka plan olduğu için atlanır
        print(f"  - Bölge {label}:")
        print(f"    - Alan: {stats[label, cv2.CC_STAT_AREA]}")
        print(f"    - Bounding Box: (x={stats[label, cv2.CC_STAT_LEFT]}, y={stats[label, cv2.CC_STAT_TOP]},"
              f" w={stats[label, cv2.CC_STAT_WIDTH]}, h={stats[label, cv2.CC_STAT_HEIGHT]})")
        print(f"    - Merkez Koordinatları: {centroids[label]}")
    print("\n" + "=" * 50 + "\n")

"""### 5.3.	Elde ettiğiniz labellar için, Centroid ve Area bilgilerinin kesinlikle olacağı, ayrıca bölgelerin yoğunluk ve şekilsel özelliklerini belirten en az 5 tane özniteliği print edin.
o	(cv2.connectedComponentsWithStats önerebilirim ama scikit-image’ın regionprops u daha iyi)

"""

from skimage.measure import regionprops, label
from skimage import morphology, filters
import numpy as np
import matplotlib.pyplot as plt

for i, binary_image in enumerate(binary_images):
    # 🔹 Otsu Thresholding
    threshold = filters.threshold_otsu(binary_image)
    mask = binary_image > threshold

    # 🔹 Morfolojik İşlemler
    mask = morphology.remove_small_objects(mask, 50)
    mask = morphology.remove_small_holes(mask, 50)

    # 🔹 Bağlantılı Bileşenler Etiketleme
    labels = label(mask)

    # 🔹 Regionprops ile Öznitelik Çıkarma
    regions = regionprops(labels, intensity_image=binary_image)

    print(f"\nGörüntü {i+1} için bağlantılı bileşen analizi:")
    print("=" * 60)

    for region in regions:
        centroid = region.centroid
        area = region.area
        perimeter = region.perimeter
        eccentricity = region.eccentricity
        mean_intensity = region.mean_intensity

        print(f"  - Bölge ID: {region.label}")
        print(f"    - Merkez (Centroid): {centroid}")
        print(f"    - Alan (Area): {area}")
        print(f"    - Çevre (Perimeter): {perimeter}")
        print(f"    - Eksantriklik (Eccentricity): {eccentricity:.2f}")
        print(f"    - Ortalama Yoğunluk (Mean Intensity): {mean_intensity:.2f}")
        print("-" * 60)

    # 🔹 CCL Çıktısını Görselleştirme
    plt.figure(figsize=(8, 6))
    plt.imshow(labels, cmap='nipy_spectral')
    plt.title(f"Görüntü {i+1} - Bağlantılı Bileşenler (CCL)")
    plt.axis("off")
    plt.colorbar()
    plt.show()

"""### 5.4.	Elde ettiğiniz stats ve labelsları inceleyerek akciğer alanlarını en iyi ifade eden öznitelikleri yorumlayınız.
o	Belirlediğniz özniteliklere göre filtreleme yapın. (örn: maks alana sahip ilk iki bölge, if maks alana sahip iki bölge and bölgelerin centroidleri ortada; filter; else try 3. Bölge; return)
o	Belirleyici öznitelik bulunamadıysa. Her görüntüde otomatik olarak label belirleyen algoritmayı yazın

"""

from skimage.measure import regionprops, label
from skimage import morphology, filters
import numpy as np
import cv2
import matplotlib.pyplot as plt

def detect_lungs(binary_image):
    """ Akciğer alanlarını en iyi ifade eden iki bölgeyi belirle """

    # 🔹 Bağlantılı Bileşenleri Etiketleme
    labels = label(binary_image)
    regions = regionprops(labels, intensity_image=binary_image)

    # 🔹 Özniteliklerin Alınması
    lung_regions = sorted(regions, key=lambda x: x.area, reverse=True)[:3]  # En büyük 3 bölgeyi al

    # 🔹 Görüntü Merkezi
    image_center = (binary_image.shape[1] // 2, binary_image.shape[0] // 2)

    selected_regions = []

    for region in lung_regions:
        centroid_x, centroid_y = region.centroid
        area = region.area
        eccentricity = region.eccentricity

        # 🔹 Şartlar: Alan büyük olacak ve centroid merkeze yakın olacak
        if (abs(centroid_x - image_center[0]) < image_center[0] * 0.3) and (eccentricity > 0.6):
            selected_regions.append(region)

        if len(selected_regions) == 2:
            break  # En iyi 2 bölgeyi seçtik

    # 🔹 Eğer 2 bölge bulunamadıysa, 3. bölgeyi dene
    if len(selected_regions) < 2 and len(lung_regions) > 2:
        selected_regions.append(lung_regions[2])

    # 🔹 Sonuçları Görselleştir
    mask = np.zeros_like(binary_image)
    for region in selected_regions:
        mask[labels == region.label] = 1

    return mask, selected_regions

# 🔹 Tüm Görüntüler İçin Uygula
for i, binary_image in enumerate(binary_images):
    lung_mask, selected_regions = detect_lungs(binary_image)

    # 🔹 Sonuçları Görselleştir
    plt.figure(figsize=(12, 6))

    plt.subplot(1, 2, 1)
    plt.imshow(binary_image, cmap='gray')
    plt.title(f"Görüntü {i+1} - Orijinal Binary")
    plt.axis("off")

    plt.subplot(1, 2, 2)
    plt.imshow(lung_mask, cmap='gray')
    plt.title(f"Görüntü {i+1} - Seçilen Akciğer Bölgeleri")
    plt.axis("off")

    plt.tight_layout()
    plt.show()

    # 🔹 Seçilen Bölgelere Ait Öznitelikler
    print(f"\nGörüntü {i+1} için seçilen akciğer bölgeleri:")
    print("=" * 60)
    for region in selected_regions:
        print(f"  - Bölge ID: {region.label}")
        print(f"    - Merkez (Centroid): {region.centroid}")
        print(f"    - Alan (Area): {region.area}")
        print(f"    - Eksantriklik (Eccentricity): {region.eccentricity:.2f}")
        print("-" * 60)

"""### 5.5.	Seçtiğiniz labela sahip filtrelenmiş görüntülere uygun morfolojik işlemleri (structural elemant tipi ve boyutu belirleyerek) uygulayın. Giriş ve çıkış görüntülerini görselleştirin."""

from skimage.morphology import binary_erosion, binary_dilation, binary_closing, disk
import numpy as np
import matplotlib.pyplot as plt

def apply_morphology_fixed(lung_mask):
    """ Akciğer maskesine uygun morfolojik işlemler uygula. """

    # 🔹 Maskenin tamamen siyah olup olmadığını kontrol et
    unique_vals = np.unique(lung_mask)
    if len(unique_vals) == 1 and unique_vals[0] == 0:
        print("UYARI: Akciğer maskesi tamamen siyah! İşlemi atlıyoruz.")
        return lung_mask, lung_mask, lung_mask

    # 🔹 Daha küçük structuring element (Disk, Boyut = 2)
    struct_elem = disk(2)

    # 🔹 Morfolojik İşlemler
    eroded = binary_erosion(lung_mask, struct_elem)  # Gürültü temizle (çok küçültmesin)
    dilated = binary_dilation(eroded, disk(10))  # Yapıyı biraz daha genişlet
    closed = binary_closing(dilated, struct_elem)  # Küçük boşlukları kapat

    return eroded, dilated, closed

# 🔹 Tüm Görüntüler İçin Uygula
for i, binary_image in enumerate(binary_images):
    lung_mask, selected_regions = detect_lungs(binary_image)

    # Morfolojik işlemleri uygula
    eroded, dilated, closed = apply_morphology_fixed(lung_mask)

    # 🔹 Sonuçları Görselleştir
    plt.figure(figsize=(18, 6))

    plt.subplot(1, 4, 1)
    plt.imshow(binary_image, cmap='gray')
    plt.title(f"Görüntü {i+1} - Orijinal Binary")
    plt.axis("off")

    plt.subplot(1, 4, 2)
    plt.imshow(eroded, cmap='gray')
    plt.title(f"Görüntü {i+1} - Erozyon Uygulandı")
    plt.axis("off")

    plt.subplot(1, 4, 3)
    plt.imshow(dilated, cmap='gray')
    plt.title(f"Görüntü {i+1} - Dilatasyon Uygulandı")
    plt.axis("off")

    plt.subplot(1, 4, 4)
    plt.imshow(closed, cmap='gray')
    plt.title(f"Görüntü {i+1} - Closing Uygulandı")
    plt.axis("off")

    plt.tight_layout()
    plt.show()

# Post-Processing (Morfolojik Operasyonlar)
    if not binary_images:
        print("Hata: Binary görüntüler mevcut değil. Thresholding aşamasını kontrol edin.")
    else:
        for i, binary_image in enumerate(binary_images):
            # Structuring Element ve Morfolojik Operasyonlar
            struct_elem = morphology.disk(3)  # Disk şeklinde bir structuring element
            morphed_image = morphology.binary_closing(binary_image, struct_elem)  # Closing işlemi

            # Giriş ve Çıkış Görüntülerini Görselleştir
            plt.figure(figsize=(12, 6))

            # Giriş Binary Görüntü
            plt.subplot(1, 2, 1)
            plt.imshow(binary_image, cmap='gray')
            plt.title("Giriş Binary Görüntü")
            plt.axis("off")

            # Çıkış Morfolojik İşlem Görüntüsü
            plt.subplot(1, 2, 2)
            plt.imshow(morphed_image, cmap='gray')
            plt.title("Morfolojik İşlem Çıkışı")
            plt.axis("off")

            plt.tight_layout()
            plt.show()

            # Yorumlama
            print(f"Görüntü {i+1} için Morfolojik İşlem:")
            print("  - Disk şeklinde structuring element kullanıldı (yarıçap = 3).")
            print("  - Closing işlemi uygulandı: Küçük boşluklar kapatıldı ve nesne kenarları düzeltildi.")
            print("\n")

"""# Sonuçlar"""

import numpy as np
import cv2
import matplotlib.pyplot as plt
from skimage.measure import regionprops, label
from skimage.morphology import binary_erosion, binary_dilation, binary_closing, disk

def detect_lungs_fixed(binary_image):
    """Bağlantılı bileşen analizi ile en büyük akciğer bölgelerini seç"""

    # Bağlantılı bileşenleri bul
    labeled_mask, num_labels = label(binary_image, return_num=True)

    # Regionprops ile bileşenlerin alanlarını ve centroidlerini al
    regions = regionprops(labeled_mask)

    # Eğer hiç bölge yoksa, maskeyi direkt dön
    if not regions:
        return np.zeros_like(binary_image), []

    # Alanlara göre sıralama (Büyükten küçüğe)
    sorted_regions = sorted(regions, key=lambda r: r.area, reverse=True)

    # İlk iki büyük bölgeyi al
    lung_mask = np.zeros_like(binary_image)
    for region in sorted_regions[:2]:  # En büyük 2 bölgeyi seçiyoruz
        lung_mask[labeled_mask == region.label] = 1

    return lung_mask, sorted_regions[:2]

# 🔹 Görüntüler Üzerinde Uygula
for i, (binary_image, original_image) in enumerate(zip(binary_images, selected_images)):
    lung_mask, selected_regions = detect_lungs_fixed(binary_image)

    # 🔹 Morfolojik İşlemler
    _, _, closed_mask = apply_morphology_fixed(lung_mask)

    # 🔹 Maskeyi Orijinal Görüntü ile Çarp (Boyutları Eşitle)
    resized_mask = cv2.resize(closed_mask.astype(np.uint8), (original_image.shape[1], original_image.shape[0]))
    processed_result = original_image * resized_mask  # Maskeyi uygula

    # 🔹 Sonuçları Görselleştir
    plt.figure(figsize=(18, 6))

    plt.subplot(1, 3, 1)
    plt.imshow(original_image, cmap='gray')
    plt.title(f"Görüntü {i+1} - Orijinal")
    plt.axis("off")

    plt.subplot(1, 3, 2)
    plt.imshow(resized_mask, cmap='gray')
    plt.title(f"Görüntü {i+1} - Binary Maske")
    plt.axis("off")

    plt.subplot(1, 3, 3)
    plt.imshow(processed_result, cmap='gray')
    plt.title(f"Görüntü {i+1} - Maske ile Çarpılmış Görüntü")
    plt.axis("off")

    plt.tight_layout()
    plt.show()

    # 🔹 Yorumlama
    print(f"Görüntü {i+1} İçin Sonuçlar:")
    print("=" * 60)
    print(f"  - Bağlantılı bileşen analiziyle **en büyük 2 bölge** seçildi.")
    print(f"  - Eğer hala yanlış çıktı oluyorsa, **3. en büyük bölge de denenebilir.**")
    print("\n")

"""# Sonuçlar V2"""

# Son Aşama: Post-Processing (Morfolojik Operasyonlar ve CCL)
    if not binary_images:
        print("Hata: Binary görüntüler mevcut değil. Thresholding aşamasını kontrol edin.")
    else:
        for i, (binary_image, original_image) in enumerate(zip(binary_images, selected_images)):
            # Structuring Element ve Morfolojik Operasyonlar
            struct_elem = morphology.disk(3)  # Disk şeklinde bir structuring element
            morphed_image = morphology.binary_closing(binary_image, struct_elem)  # Closing işlemi

            # Giriş ve Çıkış Görüntülerini Görselleştir
            plt.figure(figsize=(12, 6))

            # Giriş Binary Görüntü
            plt.subplot(1, 2, 1)
            plt.imshow(binary_image, cmap='gray')
            plt.title("Giriş Binary Görüntü")
            plt.axis("off")

            # Çıkış Morfolojik İşlem Görüntüsü
            plt.subplot(1, 2, 2)
            plt.imshow(morphed_image, cmap='gray')
            plt.title("Morfolojik İşlem Çıkışı")
            plt.axis("off")

            plt.tight_layout()
            plt.show()

            # CCL Uygulama
            num_labels, labels_im = cv2.connectedComponents(morphed_image.astype(np.uint8))

            # CCL Çıktısını Görselleştir
            plt.figure(figsize=(8, 6))
            plt.imshow(labels_im, cmap='nipy_spectral')
            plt.title(f"Görüntü {i+1} - Bağlantılı Bileşenler (CCL)")
            plt.axis("off")
            plt.colorbar()
            plt.show()

            # Bölge Sayısını Yazdır
            print(f"Görüntü {i+1} için bağlantılı bileşen sayısı: {num_labels}")

            # Maske ile Orijinal Görüntüyü Çarp (Boyutları eşitlemek için morphed_image'ı yeniden boyutlandır)
            resized_mask = cv2.resize(morphed_image.astype(np.uint8), (original_image.shape[1], original_image.shape[0]))
            processed_result = original_image * resized_mask

            # Orijinal Görüntü ve Sonuç Görüntüsünü Görselleştir
            plt.figure(figsize=(12, 6))

            plt.subplot(1, 2, 1)
            plt.imshow(original_image, cmap='gray')
            plt.title("Orijinal Görüntü")
            plt.axis("off")

            plt.subplot(1, 2, 2)
            plt.imshow(processed_result, cmap='gray')
            plt.title("Maske ile Çarpılmış Görüntü")
            plt.axis("off")

            plt.tight_layout()
            plt.show()

            # Yorumlama
            print(f"Görüntü {i+1} için İşlem Sonuçları:")
            print("  - Orijinal görüntü ile maske çarpılarak sadece ilgili bölgeler ön plana çıkarılmıştır.")
            print("  - Maske sayesinde gereksiz bölgeler kaldırılmıştır.")
            print("\n")